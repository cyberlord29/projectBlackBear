(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-shape')) :
  typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-shape'], factory) :
  (factory((global.fc = global.fc || {}),global.d3,global.d3));
}(this, (function (exports,d3Selection,d3Shape) { 'use strict';

// "Caution: avoid interpolating to or from the number zero when the interpolator is used to generate
// a string (such as with attr).
// Very small values, when stringified, may be converted to scientific notation and
// cause a temporarily invalid attribute or style property value.
// For example, the number 0.0000001 is converted to the string "1e-7".
// This is particularly noticeable when interpolating opacity values.
// To avoid scientific notation, start or end the transition at 1e-6,
// which is the smallest value that is not stringified in exponential notation."
// - https://github.com/mbostock/d3/wiki/Transitions#d3_interpolateNumber
var effectivelyZero = 1e-6;

// Wrapper around d3's selectAll/data data-join, which allows decoration of the result.
// This is achieved by appending the element to the enter selection before exposing it.
// A default transition of fade in/out is also implicitly added but can be modified.
var _dataJoin = (function (element, className) {
    element = element || 'g';

    var key = function key(_, i) {
        return i;
    };
    var explicitTransition = null;

    var dataJoin = function dataJoin(container, data) {
        data = data || function (d) {
            return d;
        };

        var implicitTransition = container.selection ? container : null;
        if (implicitTransition) {
            container = container.selection();
        }

        var selected = container.selectAll(function (d, i, nodes) {
            return Array.from(nodes[i].childNodes).filter(function (node) {
                return node.nodeType === 1;
            });
        }).filter(className == null ? element : element + '.' + className);
        var update = selected.data(data, key);

        var enter = update.enter().append(element).attr('class', className);

        var exit = update.exit();

        // automatically merge in the enter selection
        update = update.merge(enter);

        // if transitions are enabled apply a default fade in/out transition
        var transition = implicitTransition || explicitTransition;
        if (transition) {
            update = update.transition(transition).style('opacity', 1);
            enter.style('opacity', effectivelyZero);
            exit = exit.transition(transition).style('opacity', effectivelyZero);
        }

        exit.remove();

        update.enter = function () {
            return enter;
        };
        update.exit = function () {
            return exit;
        };

        return update;
    };

    dataJoin.element = function () {
        if (!arguments.length) {
            return element;
        }
        element = arguments.length <= 0 ? undefined : arguments[0];
        return dataJoin;
    };
    dataJoin.className = function () {
        if (!arguments.length) {
            return className;
        }
        className = arguments.length <= 0 ? undefined : arguments[0];
        return dataJoin;
    };
    dataJoin.key = function () {
        if (!arguments.length) {
            return key;
        }
        key = arguments.length <= 0 ? undefined : arguments[0];
        return dataJoin;
    };
    dataJoin.transition = function () {
        if (!arguments.length) {
            return explicitTransition;
        }
        explicitTransition = arguments.length <= 0 ? undefined : arguments[0];
        return dataJoin;
    };

    return dataJoin;
});

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var identity = function identity(d) {
    return d;
};

var axis = function axis(orient, scale) {

    var tickArguments = [10];
    var tickValues = null;
    var decorate = function decorate() {};
    var tickFormat = null;
    var tickSizeOuter = 6;
    var tickSizeInner = 6;
    var tickPadding = 3;

    var svgDomainLine = d3Shape.line();

    var dataJoin$$1 = _dataJoin('g', 'tick').key(identity);

    var domainPathDataJoin = _dataJoin('path', 'domain');

    // returns a function that creates a translation based on
    // the bound data
    var containerTranslate = function containerTranslate(scale, trans) {
        var offset = 0;
        if (scale.bandwidth) {
            offset = scale.bandwidth() / 2;
            if (scale.round()) {
                offset = Math.round(offset);
            }
        }
        return function (d) {
            return trans(scale(d) + offset, 0);
        };
    };

    var translate = function translate(x, y) {
        return isVertical() ? 'translate(' + y + ', ' + x + ')' : 'translate(' + x + ', ' + y + ')';
    };

    var pathTranspose = function pathTranspose(arr) {
        return isVertical() ? arr.map(function (d) {
            return [d[1], d[0]];
        }) : arr;
    };

    var isVertical = function isVertical() {
        return orient === 'left' || orient === 'right';
    };

    var tryApply = function tryApply(fn, args, defaultVal) {
        return scale[fn] ? scale[fn].apply(scale, args) : defaultVal;
    };

    var axis = function axis(selection) {

        if (selection.selection) {
            dataJoin$$1.transition(selection);
            domainPathDataJoin.transition(selection);
        }

        selection.each(function (data, index, group) {

            var element = group[index];

            var container = d3Selection.select(element);
            if (!element.__scale__) {
                container.attr('fill', 'none').attr('font-size', 10).attr('font-family', 'sans-serif').attr('text-anchor', orient === 'right' ? 'start' : orient === 'left' ? 'end' : 'middle');
            }

            // Stash a snapshot of the new scale, and retrieve the old snapshot.
            var scaleOld = element.__scale__ || scale;
            element.__scale__ = scale.copy();

            var ticksArray = tickValues == null ? tryApply('ticks', tickArguments, scale.domain()) : tickValues;
            var tickFormatter = tickFormat == null ? tryApply('tickFormat', tickArguments, identity) : tickFormat;
            var sign = orient === 'bottom' || orient === 'right' ? 1 : -1;

            // add the domain line
            var range = scale.range();
            var domainPathData = pathTranspose([[range[0], sign * tickSizeOuter], [range[0], 0], [range[1], 0], [range[1], sign * tickSizeOuter]]);

            var domainLine = domainPathDataJoin(container, [data]);
            domainLine.attr('d', svgDomainLine(domainPathData)).attr('stroke', '#000');

            var g = dataJoin$$1(container, ticksArray);

            // enter
            g.enter().attr('transform', containerTranslate(scaleOld, translate)).append('path').attr('stroke', '#000');

            var labelOffset = sign * (tickSizeInner + tickPadding);
            g.enter().append('text').attr('transform', translate(0, labelOffset)).attr('fill', '#000');

            // exit
            g.exit().attr('transform', containerTranslate(scale, translate));

            // update
            g.select('path').attr('d', function (d) {
                return svgDomainLine(pathTranspose([[0, 0], [0, sign * tickSizeInner]]));
            });

            g.select('text').attr('transform', translate(0, labelOffset)).attr('dy', function () {
                var offset = '0em';
                if (isVertical()) {
                    offset = '0.32em';
                } else if (orient === 'bottom') {
                    offset = '0.71em';
                }
                return offset;
            }).text(tickFormatter);

            g.attr('transform', containerTranslate(scale, translate));

            decorate(g, data, index);
        });
    };

    axis.tickFormat = function () {
        if (!arguments.length) {
            return tickFormat;
        }
        tickFormat = arguments.length <= 0 ? undefined : arguments[0];
        return axis;
    };

    axis.tickSize = function () {
        if (!arguments.length) {
            return tickSizeInner;
        }
        tickSizeInner = tickSizeOuter = Number(arguments.length <= 0 ? undefined : arguments[0]);
        return axis;
    };

    axis.tickSizeInner = function () {
        if (!arguments.length) {
            return tickSizeInner;
        }
        tickSizeInner = Number(arguments.length <= 0 ? undefined : arguments[0]);
        return axis;
    };

    axis.tickSizeOuter = function () {
        if (!arguments.length) {
            return tickSizeOuter;
        }
        tickSizeOuter = Number(arguments.length <= 0 ? undefined : arguments[0]);
        return axis;
    };

    axis.tickPadding = function () {
        if (!arguments.length) {
            return tickPadding;
        }
        tickPadding = arguments.length <= 0 ? undefined : arguments[0];
        return axis;
    };

    axis.decorate = function () {
        if (!arguments.length) {
            return decorate;
        }
        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return axis;
    };

    axis.scale = function () {
        if (!arguments.length) {
            return scale;
        }
        scale = arguments.length <= 0 ? undefined : arguments[0];
        return axis;
    };

    axis.ticks = function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        tickArguments = [].concat(args);
        return axis;
    };

    axis.tickArguments = function () {
        if (!arguments.length) {
            return tickArguments.slice();
        }
        tickArguments = (arguments.length <= 0 ? undefined : arguments[0]) == null ? [] : [].concat(toConsumableArray(arguments.length <= 0 ? undefined : arguments[0]));
        return axis;
    };

    axis.tickValues = function () {
        if (!arguments.length) {
            return tickValues.slice();
        }
        tickValues = (arguments.length <= 0 ? undefined : arguments[0]) == null ? [] : [].concat(toConsumableArray(arguments.length <= 0 ? undefined : arguments[0]));
        return axis;
    };

    return axis;
};

var axisTop = function axisTop(scale) {
    return axis('top', scale);
};

var axisBottom = function axisBottom(scale) {
    return axis('bottom', scale);
};

var axisLeft = function axisLeft(scale) {
    return axis('left', scale);
};

var axisRight = function axisRight(scale) {
    return axis('right', scale);
};

exports.axisTop = axisTop;
exports.axisBottom = axisBottom;
exports.axisLeft = axisLeft;
exports.axisRight = axisRight;

Object.defineProperty(exports, '__esModule', { value: true });

})));
